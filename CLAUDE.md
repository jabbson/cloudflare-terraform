# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Overview

Terraform project managing Cloudflare DNS, Zero Trust Tunnels, and Email Routing for the `jabbson.xyz` domain. Uses Cloudflare provider v5 (`~> 5`) and requires Terraform >= 1.5.0.

## Required Environment Variables

Credentials are stored in `.env` (gitignored). Copy `.env.example` to `.env` and fill in all three values. Source it before running any command:

```bash
source .env
```

All three variables are required — `generate.sh` will fail immediately if any are missing:
- `CLOUDFLARE_API_TOKEN` — Bearer token, also the only env var read by the Cloudflare provider
- `ZONE_ID` — Cloudflare zone ID for the domain
- `ACCOUNT_ID` — Cloudflare account ID

`zone_id` and `account_id` are also required Terraform variables — they are written into `dns.auto.tfvars.json` / `tunnels.auto.tfvars.json` by `generate.sh` and loaded automatically from there.

## Workflow

Most `*.auto.tfvars.json` files and `imports.tf` are **generated artifacts** — do not edit them by hand. All `*.auto.tfvars.json` files are gitignored; the hand-managed extra files (`dns_extra`, `tunnels_extra`, `email_routing_extra`) each have a committed `.example` counterpart to copy from.

```bash
# 0. Load credentials
source .env

# 1. Sync state from Cloudflare API → regenerate tfvars + imports
./generate.sh

# 2. Standard Terraform workflow (init only needed once or after provider changes)
terraform init
terraform plan
terraform apply
```

### Resetting state (after major refactors or to re-import everything clean)

```bash
rm -f terraform.tfstate terraform.tfstate.backup
source .env && ./generate.sh
terraform apply   # re-imports all 46 resources from live Cloudflare state
```

`generate.sh` fetches live state from the Cloudflare API and writes:
- `dns.auto.tfvars.json` — all DNS records (excluding names in `dns_extra.auto.tfvars.json`)
- `tunnels.auto.tfvars.json` — Zero Trust tunnels (excluding names in `tunnels_extra.auto.tfvars.json`)
- `email_routing.auto.tfvars.json` — email routing rules, addresses, catch-all (excluding emails/names in `email_routing_extra.auto.tfvars.json`)
- `imports.tf` — import blocks for every resource (regenerated each run, same exclusions apply)

### Adding resources via Terraform (no generate.sh needed)

All three resource types support a hand-managed "extra" pool. Copy the relevant `.example` file and add entries directly:

| Resource | File to edit | Example file |
|----------|-------------|--------------|
| DNS records | `dns_extra.auto.tfvars.json` | `dns_extra.auto.tfvars.json.example` |
| Tunnels | `tunnels_extra.auto.tfvars.json` | `tunnels_extra.auto.tfvars.json.example` |
| Email addresses + rules | `email_routing_extra.auto.tfvars.json` | `email_routing_extra.auto.tfvars.json.example` |

All three files are gitignored — copy from the `.example` and fill in your values. Then run `terraform plan` → `terraform apply`. No dashboard. No API call. No `generate.sh`.

Extra-managed resources are excluded from `generate.sh` output by name/email match, so they will never appear in the generated pools or import blocks.

## Architecture

**Flat root module** — no submodules. All resources live in the root.

| File | Purpose |
|------|---------|
| `providers.tf` | Cloudflare provider, auth via env vars |
| `variables.tf` | Input variable declarations |
| `dns.tf` | `cloudflare_dns_record.this` (imported) + `cloudflare_dns_record.extra` (hand-managed) |
| `dns_extra.auto.tfvars.json` | Hand-managed DNS records — gitignored, copy from `.example` |
| `dns_extra.auto.tfvars.json.example` | Example/template for `dns_extra` — committed to git |
| `tunnels.tf` | `cloudflare_zero_trust_tunnel_cloudflared.this` (imported) + `.extra` (hand-managed) |
| `tunnels_extra.auto.tfvars.json` | Hand-managed tunnels — gitignored, copy from `.example` |
| `tunnels_extra.auto.tfvars.json.example` | Example/template for `tunnels_extra` — committed to git |
| `email_routing.tf` | Email routing settings, addresses, rules, catch-all + extra address/rule resources |
| `email_routing_extra.auto.tfvars.json` | Hand-managed email addresses + rules — gitignored, copy from `.example` |
| `email_routing_extra.auto.tfvars.json.example` | Example/template for `email_routing_extra` — committed to git |
| `imports.tf` | Auto-generated import blocks — regenerated by `generate.sh` |
| `generate.sh` | Calls Cloudflare API and writes all `*.auto.tfvars.json` + `imports.tf` |
| `traefik.auto.tfvars` | Sets `traefik_ip` (hand-managed, not regenerated, gitignored — copy from `traefik.auto.tfvars.example`) |

## Key Design Patterns

**Traefik IP injection**: `dns.tf` uses a local to override the `content` of any A record tagged with `comment = "traefik"` with `var.traefik_ip` from `traefik.auto.tfvars`. This applies to both the imported pool (`cloudflare_dns_record.this`) and the hand-managed pool (`cloudflare_dns_record.extra`). `traefik.auto.tfvars` is gitignored (contains real server IP) — copy `traefik.auto.tfvars.example` to `traefik.auto.tfvars` and set the real IP. Update it when the Traefik host IP changes.

**Two-pool pattern** (applied to all three resource types): Each resource type has an imported pool (generated by `generate.sh`) and an extra pool (hand-managed, gitignored):

| Resource | Imported pool | Extra pool |
|----------|--------------|------------|
| DNS | `dns_records` / `cloudflare_dns_record.this` | `dns_extra_records` / `cloudflare_dns_record.extra` |
| Tunnels | `tunnels` / `cloudflare_zero_trust_tunnel_cloudflared.this` | `tunnels_extra` / `cloudflare_zero_trust_tunnel_cloudflared.extra` |
| Email addresses | `email_routing_addresses` / `cloudflare_email_routing_address.this` | `email_routing_addresses_extra` / `cloudflare_email_routing_address.extra` |
| Email rules | `email_routing_rules` / `cloudflare_email_routing_rule.this` | `email_routing_rules_extra` / `cloudflare_email_routing_rule.extra` |

The two pools cannot overlap: `generate.sh` reads each extra file and excludes matching names/emails from the generated pool and import blocks. Extra files are gitignored — copy from the corresponding `.example` file.

**Import-based management**: Resources are imported from Cloudflare rather than created fresh. `imports.tf` is regenerated on every `generate.sh` run and covers all DNS records, tunnels, email routing addresses, rules, and the catch-all.

**Prevent destroy**: All resources have `lifecycle { prevent_destroy = true }`. Removing a resource requires removing both the resource block and this lifecycle protection.

**Email routing variable types**: `email_routing_rules` uses `map(object({...}))` with `optional()` fields throughout. This is intentional — forward rules have `actions[].value` and `matchers[].field/value`, but drop-action rules and the all-matcher do not. Using `optional()` lets Terraform normalize the shapes without type errors. Do not change this to `map(any)`.

**Email routing catch-all**: The Cloudflare API returns the catch-all inside the `/email/routing/rules` list (type=all matcher, priority=2147483647). `generate.sh` filters it out and writes it separately. It is managed by `cloudflare_email_routing_catch_all`, not `cloudflare_email_routing_rule`.

**Resource ID patterns**:
- DNS records: `zone_id/record_id`
- Tunnels: `account_id/tunnel_id`
- Email addresses: `account_id/address_id`
- Email rules: `zone_id/rule_id`
- Catch-all: `zone_id`
